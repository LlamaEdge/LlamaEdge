use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use crate::chat::{JsonObject};

/// Represents a response object from the API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseObject {
    /// Whether to run the model response in the background.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub background: Option<bool>,
    /// The conversation that this response belongs to. Input items and output items from this response are automatically added to this conversation.
    // #[serde(skip_serializing_if = "Option::is_none")]
    // pub conversation: Option<Conversation>,
    /// Unix timestamp (in seconds) of when this Response was created.
    pub created_at: u64,
    /// An error object returned when the model fails to generate a Response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ResponseObjectError>,
    /// Unique identifier for this Response.
    pub id: String,
    /// Details about why the response is incomplete.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incomplete_details: Option<ResponseObjectIncompleteDetails>,
    /// A system (or developer) message inserted into the model's context.
    ///
    /// When using along with `previous_response_id`, the instructions from a previous response will not be carried over to the next response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instructions: Option<ResponseObjectInstructions>,
    /// An upper bound for the number of tokens that can be generated for a response, including visible output tokens and reasoning tokens.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_output_tokens: Option<u32>,
    /// The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tool_calls: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// Model ID used to generate the response.
    pub model: String,
    /// The object type of this resource - always set to `response`.
    pub object: String,
    /// An array of content items generated by the model.
    pub output: Vec<OutputItem>,
    /// Whether to allow the model to run tool calls in parallel.
    pub parallel_tool_calls: bool,
    /// The unique ID of the previous response to the model. Use this to create multi-turn conversations.
    pub previous_response_id: Option<String>,
    /// The status of the response generation. One of `completed`, `failed`, `in_progress`, `cancelled`, `queued`, or `incomplete`.
    pub status: String,
    /// What sampling temperature to use.
    pub temperature: f64,
    /// Controls which (if any) function is called by the model.
    pub tool_choice: ToolChoice,
    /// An array of tools the model may call while generating a response.
    pub tools: Option<Vec<Tool>>,
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
    /// It's recommended that altering this or temperature but not both.
    pub top_p: f64,
    /// Represents token usage details including input tokens, output tokens, a breakdown of output tokens, and the total tokens used.
    pub usage: Usage,

}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseObjectError {
    /// The error code for the response.
    pub code: String,
    /// A human-readable description of the error.
    pub message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseObjectIncompleteDetails {
    /// The reason why the response is incomplete.
    pub reason: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResponseObjectInstructions {
    /// A text input to the model, equivalent to a text input with the `developer` role.
    Text(String),
    /// A list of one or many input items to the model, containing different content types.
    InputItemList(Vec<InstructionInputMessage>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InstructionInputMessage {
    /// The role of the message input. One of `user`, `assistant`, `system`, or `developer`.
    pub role: String,
    /// Text, image, or audio input to the model, used to generate a response. Can also contain previous assistant responses.
    pub content: InstructionInputMessageContent,
    /// The type of the message input. Always message.
    #[serde(rename = "type")]
    pub ty: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InstructionInputMessageContent {
    /// A text input to the model.
    Text(String),
    /// A list of one or many input items to the model, containing different content types.
    InputItemContentList(Vec<InstructionInputContentItem>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InstructionInputContentItem {
    Text {
        /// The text input to the model.
        text: String,
        /// The type of the input item. Always `input_text`.
        #[serde(rename = "type")]
        ty: String,
    },
    Image {
        /// The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.
        detail: String,
        /// The type of the input item. Always `input_image`.
        #[serde(rename = "type")]
        ty: String,
        /// The ID of the file to be sent to the model.
        file_id: String,
        /// The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.
        image_url: String,
    },
    File {
        /// The type of the input item. Always input_file.
        #[serde(rename = "type")]
        ty: String,
        /// The content of the file to be sent to the model.
        file_data: String,
        /// The ID of the file to be sent to the model.
        file_id: String,
        /// The URL of the file to be sent to the model.
        file_url: String,
        /// The name of the file to be sent to the model.
        filename: String,
    },
    Audio {
        /// The type of the input item. Always `input_audio`.
        #[serde(rename = "type")]
        ty: String,
        input_audio: InstructionInputAudio,
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InstructionInputAudio {
    /// Base64-encoded audio data.
    data: String,
    /// The format of the audio data. Currently supported formats are `mp3` and `wav`.
    format: String,
}

/// Represents different types of output items in the response
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum OutputItem {
    /// An output message from the model.
    #[serde(rename = "message")]
    Message {
        /// The unique ID of the output message.
        id: String,
        /// The status of the message input. One of `in_progress`, `completed`, or `incomplete`.
        status: String,
        /// The role of the output message. Always `assistant`.
        role: String,
        /// The content of the output message.
        content: Vec<ContentItem>,
    },

    /// A tool call to run a function.
    #[serde(rename = "function_call")]
    FunctionToolCall {
        /// A JSON string of the arguments to pass to the function.
        arguments: String,
        /// The unique ID of the function tool call generated by the model.
        call_id: String,
        /// The name of the function to run.
        name: String,
        /// The unique ID of the function tool call.
        id: String,
        /// The status of the function tool call. One of `in_progress`, `completed`, or `incomplete`.
        status: String,
    },

    /// An invocation of a tool on an MCP server.
    #[serde(rename = "mcp_call")]
    McpToolCall {
        /// A JSON string of the arguments passed to the tool.
        arguments: String,
        /// The unique ID of the tool call.
        id: String,
        /// The name of the tool that was run.
        name: String,
        /// The label of the MCP server running the tool.
        server_label: String,
        /// The error from the tool call, if any.
        error: Option<String>,
        /// The status of the MCP tool call. One of `in_progress`, `completed`, or `incomplete`.
        status: String,
        /// The output from the tool call.
        output: Option<String>,
    },

    /// A list of tools available on an MCP server.
    #[serde(rename = "mcp_list_tools")]
    McpListTools {
        /// The unique ID of the list.
        id: String,
        /// The label of the MCP server.
        server_label: String,
        /// The tools available on the server.
        tools: Vec<OutputMcpTool>,
        /// The error from the tool call, if any.
        error: Option<String>,
    },
}

/// Represents different types of content within a response message
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum ContentItem {
    /// Text content type
    #[serde(rename = "output_text")]
    Text {
        /// The text output from the model.
        text: String,
        /// The annotations of the text output.
        annotations: Vec<Annotation>,
    },
    /// Refusal content type (when model refuses to answer)
    #[serde(rename = "refusal")]
    Refusal {
        refusal: String,
    },
}

/// Represents annotation information for text content
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum Annotation {
    /// A citation to a file.
    #[serde(rename = "file_citation")]
    FileCitation {
        /// The ID of the file.
        #[serde(rename = "file_id")]
        id: String,
        /// The filename of the file cited.
        filename: String,
        /// The index of the file in the list of files.
        index: usize,
    },
    /// A path to a file.
    #[serde(rename = "file_path")]
    FilePath {
        /// The ID of the file.
        #[serde(rename = "file_id")]
        id: String,
        /// The index of the file in the list of files.
        index: usize,
    },
    /// A citation for a web resource used to generate a model response.
    #[serde(rename = "url_citation")]
    UrlCitation {
        /// The index of the last character of the URL citation in the message.
        end_index: usize,
        /// The index of the first character of the URL citation in the message.
        start_index: usize,
        /// The title of the web resource.
        title: String,
        /// The URL of the web resource.
        url: String,
    },
    /// Container file citation annotation
    #[serde(rename = "container_file_citation")]
    ContainerFileCitation {
        text: String,
        container_file_citation: ContainerFileCitationDetails,
        start_index: usize,
        end_index: usize,
    },
}

/// File citation details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileCitationDetails {
    pub file_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quote: Option<String>,
}

/// File path details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilePathDetails {
    pub file_id: String,
}

/// URL citation details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UrlCitationDetails {
    pub url: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

/// Container file citation details
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ContainerFileCitationDetails {
    pub file_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quote: Option<String>,
}

/// Represents reasoning information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Reasoning {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub effort: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
}

/// Represents text format configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextFormat {
    pub format: TextFormatType,
}

/// Represents the type of text format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextFormatType {
    #[serde(rename = "type")]
    pub ty: String,
}

/// Function structure for tool calls
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct Function {
    /// The name of the function that the model called.
    pub name: String,
    /// The arguments that the model called the function with.
    pub arguments: String,
}

/// Tool call structure
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct ToolCall {
    /// The ID of the tool call.
    pub id: String,
    /// The type of the tool. Currently, only function is supported.
    #[serde(rename = "type")]
    pub ty: String,
    /// The function that the model called.
    pub function: Function,
}

/// MCP Tool definition following MCP specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputMcpTool {
    /// The name of the tool.
    pub name: String,
    /// The description of the tool.
    pub description: String,
    /// The JSON schema describing the tool's input.
    pub input_schema: JsonObject,
    /// Additional annotations about the tool.
    pub annotations: Option<Annotation>,
}

/// Controls which (if any) function is called by the model. Defaults to `None`.
#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub enum ToolChoice {
    /// Controls which (if any) tool is called by the model.
    /// `none` means the model will not call any tool and instead generates a message.
    /// `auto` means the model can pick between generating a message or calling one or more tools.
    /// `required` means the model must call one or more tools.
    #[serde(rename = "none")]
    None,
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "required")]
    Required,
    #[serde(untagged)]
    AllowedTools {
        /// Constrains the tools available to the model to a pre-defined set.
        /// `auto` allows the model to pick from among the allowed tools and generate a message.
        /// `required` requires the model to call one or more of the allowed tools.
        mode: String,
        /// A list of tool definitions that the model should be allowed to call.
        tools: Vec<ToolChoiceMcpTool>,
    },
    #[serde(untagged)]
    McpTool(ToolChoiceMcpTool),
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct ToolChoiceMcpTool {
    /// The label of the MCP server to use.
    pub server_label: String,
    /// The name of the tool to call on the server.
    pub name: String,
    /// The type of the tool. Always `mcp`.
    #[serde(rename = "type")]
    pub ty: String,
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct McpTool {
    /// A label for this MCP server, used to identify it in tool calls.
    server_label: String,
    /// The type of the MCP tool. Always `mcp`.
    #[serde(rename = "type")]
    ty: String,
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct Tool {
    /// The name of the function to call.
    pub name: String,
    /// A JSON schema object describing the parameters of the function.
    pub parameters: JsonObject,
    /// Whether to enforce strict parameter validation. Default `true`.
    pub strict: bool,
    /// The type of the function tool. Always `function`.
    #[serde(rename = "type")]
    pub ty: String,
    /// A description of the function. Used by the model to determine whether or not to call the function.
    pub description: String,
}

/// Represents token usage statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Usage {
    /// The number of input tokens.
    pub input_tokens: u32,
    /// A detailed breakdown of the input tokens.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_tokens_details: Option<InputTokensDetails>,
    /// The number of output tokens.
    pub output_tokens: u32,
    /// A detailed breakdown of the output tokens.
    pub output_tokens_details: OutputTokensDetails,
    /// The total number of tokens used.
    pub total_tokens: u32,
}

/// Represents input token details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputTokensDetails {
    /// The number of tokens that were retrieved from the cache.
    pub cached_tokens: u32,
}

/// Represents output token details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputTokensDetails {
    /// The number of reasoning tokens.
    pub reasoning_tokens: u32,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_annotation_file_citation_serialization() {
        let annotation = Annotation::FileCitation {
            id: "file_123".to_string(),
            filename: "example.txt".to_string(),
            index: 0,
        };

        let json = serde_json::to_string(&annotation).expect("Failed to serialize");
        let expected_json = r#"{"type":"file_citation","file_id":"file_123","filename":"example.txt","index":0}"#;
        assert_eq!(json, expected_json);

        let deserialized: Annotation = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, annotation);
    }

    #[test]
    fn test_annotation_file_path_serialization() {
        let annotation = Annotation::FilePath {
            id: "file_456".to_string(),
            index: 1,
        };

        let json = serde_json::to_string(&annotation).expect("Failed to serialize");
        let expected_json = r#"{"type":"file_path","file_id":"file_456","index":1}"#;
        assert_eq!(json, expected_json);

        let deserialized: Annotation = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, annotation);
    }

    #[test]
    fn test_annotation_url_citation_serialization() {
        let annotation = Annotation::UrlCitation {
            end_index: 100,
            start_index: 50,
            title: "Example Website".to_string(),
            url: "https://example.com".to_string(),
        };

        let json = serde_json::to_string(&annotation).expect("Failed to serialize");
        let expected_json = r#"{"type":"url_citation","end_index":100,"start_index":50,"title":"Example Website","url":"https://example.com"}"#;
        assert_eq!(json, expected_json);

        let deserialized: Annotation = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, annotation);
    }

    #[test]
    fn test_annotation_container_file_citation_serialization() {
        let annotation = Annotation::ContainerFileCitation {
            text: "Some quoted text".to_string(),
            container_file_citation: ContainerFileCitationDetails {
                file_id: "file_789".to_string(),
                quote: Some("quoted content".to_string()),
            },
            start_index: 10,
            end_index: 25,
        };

        let json = serde_json::to_string(&annotation).expect("Failed to serialize");
        let expected_json = r#"{"type":"container_file_citation","text":"Some quoted text","container_file_citation":{"file_id":"file_789","quote":"quoted content"},"start_index":10,"end_index":25}"#;
        assert_eq!(json, expected_json);

        let deserialized: Annotation = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, annotation);
    }

    #[test]
    fn test_annotation_container_file_citation_without_quote_serialization() {
        let annotation = Annotation::ContainerFileCitation {
            text: "Some quoted text".to_string(),
            container_file_citation: ContainerFileCitationDetails {
                file_id: "file_789".to_string(),
                quote: None,
            },
            start_index: 10,
            end_index: 25,
        };

        let json = serde_json::to_string(&annotation).expect("Failed to serialize");
        let expected_json = r#"{"type":"container_file_citation","text":"Some quoted text","container_file_citation":{"file_id":"file_789"},"start_index":10,"end_index":25}"#;
        assert_eq!(json, expected_json);

        let deserialized: Annotation = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, annotation);
    }

    #[test]
    fn test_annotation_roundtrip_all_variants() {
        let annotations = vec![
            Annotation::FileCitation {
                id: "file_123".to_string(),
                filename: "test.txt".to_string(),
                index: 0,
            },
            Annotation::FilePath {
                id: "file_456".to_string(),
                index: 1,
            },
            Annotation::UrlCitation {
                end_index: 200,
                start_index: 100,
                title: "Test Site".to_string(),
                url: "https://test.com".to_string(),
            },
            Annotation::ContainerFileCitation {
                text: "Container text".to_string(),
                container_file_citation: ContainerFileCitationDetails {
                    file_id: "file_789".to_string(),
                    quote: Some("container quote".to_string()),
                },
                start_index: 5,
                end_index: 20,
            },
        ];

        for annotation in annotations {
            let json = serde_json::to_string(&annotation).expect("Failed to serialize");
            let deserialized: Annotation = serde_json::from_str(&json).expect("Failed to deserialize");
            assert_eq!(deserialized, annotation);
        }
    }

    #[test]
    fn test_content_item_text_serialization() {
        let content_item = ContentItem::Text {
            text: "This is a sample text output".to_string(),
            annotations: vec![
                Annotation::FileCitation {
                    id: "file_123".to_string(),
                    filename: "example.txt".to_string(),
                    index: 0,
                },
            ],
        };

        let json = serde_json::to_string(&content_item).expect("Failed to serialize");
        let expected_json = r#"{"type":"output_text","text":"This is a sample text output","annotations":[{"type":"file_citation","file_id":"file_123","filename":"example.txt","index":0}]}"#;
        assert_eq!(json, expected_json);

        let deserialized: ContentItem = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, content_item);
    }

    #[test]
    fn test_content_item_text_empty_annotations_serialization() {
        let content_item = ContentItem::Text {
            text: "Text without annotations".to_string(),
            annotations: vec![],
        };

        let json = serde_json::to_string(&content_item).expect("Failed to serialize");
        let expected_json = r#"{"type":"output_text","text":"Text without annotations","annotations":[]}"#;
        assert_eq!(json, expected_json);

        let deserialized: ContentItem = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, content_item);
    }

    #[test]
    fn test_content_item_refusal_serialization() {
        let content_item = ContentItem::Refusal {
            refusal: "I cannot provide information about that topic.".to_string(),
        };

        let json = serde_json::to_string(&content_item).expect("Failed to serialize");
        let expected_json = r#"{"type":"refusal","refusal":"I cannot provide information about that topic."}"#;
        assert_eq!(json, expected_json);

        let deserialized: ContentItem = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, content_item);
    }

    #[test]
    fn test_content_item_text_multiple_annotations_serialization() {
        let content_item = ContentItem::Text {
            text: "This text has multiple annotations".to_string(),
            annotations: vec![
                Annotation::FileCitation {
                    id: "file_123".to_string(),
                    filename: "example.txt".to_string(),
                    index: 0,
                },
                Annotation::UrlCitation {
                    end_index: 50,
                    start_index: 25,
                    title: "Reference Site".to_string(),
                    url: "https://reference.com".to_string(),
                },
                Annotation::FilePath {
                    id: "file_456".to_string(),
                    index: 1,
                },
            ],
        };

        let json = serde_json::to_string(&content_item).expect("Failed to serialize");
        let deserialized: ContentItem = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, content_item);

        // Verify the structure is correct
        if let ContentItem::Text { text, annotations } = deserialized {
            assert_eq!(text, "This text has multiple annotations");
            assert_eq!(annotations.len(), 3);
        } else {
            panic!("Expected Text variant");
        }
    }

    #[test]
    fn test_content_item_roundtrip_all_variants() {
        let content_items = vec![
            ContentItem::Text {
                text: "Simple text".to_string(),
                annotations: vec![],
            },
            ContentItem::Text {
                text: "Text with annotation".to_string(),
                annotations: vec![
                    Annotation::FileCitation {
                        id: "file_123".to_string(),
                        filename: "test.txt".to_string(),
                        index: 0,
                    },
                ],
            },
            ContentItem::Refusal {
                refusal: "Access denied".to_string(),
            },
            ContentItem::Refusal {
                refusal: "This content is restricted.".to_string(),
            },
        ];

        for content_item in content_items {
            let json = serde_json::to_string(&content_item).expect("Failed to serialize");
            let deserialized: ContentItem = serde_json::from_str(&json).expect("Failed to deserialize");
            assert_eq!(deserialized, content_item);
        }
    }

    #[test]
    fn test_tool_choice_none_serialization() {
        let tool_choice = ToolChoice::None;
        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        assert_eq!(json, r#""none""#);

        let deserialized: ToolChoice = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, tool_choice);
    }

    #[test]
    fn test_tool_choice_auto_serialization() {
        let tool_choice = ToolChoice::Auto;
        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        assert_eq!(json, r#""auto""#);

        let deserialized: ToolChoice = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, tool_choice);
    }

    #[test]
    fn test_tool_choice_required_serialization() {
        let tool_choice = ToolChoice::Required;
        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        assert_eq!(json, r#""required""#);

        let deserialized: ToolChoice = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, tool_choice);
    }

    #[test]
    fn test_tool_choice_allowed_tools_serialization() {
        let tool_choice = ToolChoice::AllowedTools {
            mode: "auto".to_string(),
            tools: vec![
                ToolChoiceMcpTool {
                    server_label: "weather_server".to_string(),
                    name: "get_weather".to_string(),
                    ty: "mcp".to_string(),
                },
                ToolChoiceMcpTool {
                    server_label: "calculator_server".to_string(),
                    name: "calculate".to_string(),
                    ty: "mcp".to_string(),
                },
            ],
        };

        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        let expected_json = r#"{"mode":"auto","tools":[{"server_label":"weather_server","name":"get_weather","type":"mcp"},{"server_label":"calculator_server","name":"calculate","type":"mcp"}]}"#;
        assert_eq!(json, expected_json);

        let deserialized: ToolChoice = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, tool_choice);
    }

    #[test]
    fn test_tool_choice_allowed_tools_required_mode_serialization() {
        let tool_choice = ToolChoice::AllowedTools {
            mode: "required".to_string(),
            tools: vec![
                ToolChoiceMcpTool {
                    server_label: "file_server".to_string(),
                    name: "read_file".to_string(),
                    ty: "mcp".to_string(),
                },
            ],
        };

        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        let expected_json = r#"{"mode":"required","tools":[{"server_label":"file_server","name":"read_file","type":"mcp"}]}"#;
        assert_eq!(json, expected_json);

        let deserialized: ToolChoice = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, tool_choice);
    }

    #[test]
    fn test_tool_choice_mcp_tool_serialization() {
        let tool_choice = ToolChoice::McpTool(ToolChoiceMcpTool {
            server_label: "database_server".to_string(),
            name: "query_database".to_string(),
            ty: "mcp".to_string(),
        });

        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        let expected_json = r#"{"server_label":"database_server","name":"query_database","type":"mcp"}"#;
        assert_eq!(json, expected_json);

        let deserialized: ToolChoice = serde_json::from_str(&json).expect("Failed to deserialize");
        assert_eq!(deserialized, tool_choice);
    }

    #[test]
    fn test_tool_choice_deserialization_from_object() {
        // Test deserialization of object values
        let json = r#"{
            "mode": "auto",
            "tools": [
                {
                    "server_label": "example_server",
                    "name": "example_tool",
                    "type": "mcp"
                }
            ]
        }"#;

        let tool_choice: ToolChoice = serde_json::from_str(json).expect("Failed to deserialize");

        if let ToolChoice::AllowedTools { mode, tools } = tool_choice {
            assert_eq!(mode, "auto");
            assert_eq!(tools.len(), 1);
            assert_eq!(tools[0].server_label, "example_server");
            assert_eq!(tools[0].name, "example_tool");
            assert_eq!(tools[0].ty, "mcp");
        } else {
            panic!("Expected AllowedTools variant");
        }
    }

    #[test]
    fn test_tool_choice_mcp_tool_deserialization() {
        let json = r#"{
            "server_label": "mcp_server",
            "name": "mcp_tool",
            "type": "mcp"
        }"#;

        let tool_choice: ToolChoice = serde_json::from_str(json).expect("Failed to deserialize");

        if let ToolChoice::McpTool(tool) = tool_choice {
            assert_eq!(tool.server_label, "mcp_server");
            assert_eq!(tool.name, "mcp_tool");
            assert_eq!(tool.ty, "mcp");
        } else {
            panic!("Expected McpTool variant");
        }
    }

    #[test]
    fn test_tool_choice_mode_serialization_format() {
        // Test that Mode variant serializes directly to string without wrapper
        let tool_choice = ToolChoice::Auto;
        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");

        // Should be just "auto", not {"Mode":"auto"}
        assert_eq!(json, r#""auto""#);

        let tool_choice = ToolChoice::None;
        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        assert_eq!(json, r#""none""#);

        let tool_choice = ToolChoice::Required;
        let json = serde_json::to_string(&tool_choice).expect("Failed to serialize");
        assert_eq!(json, r#""required""#);
    }

    #[test]
    fn test_response_object_deserialization() {
        let json = r#"{
  "id": "resp_67ca09c5efe0819096d0511c92b8c890096610f474011cc0",
  "object": "response",
  "created_at": 1741294021,
  "status": "completed",
  "error": null,
  "incomplete_details": null,
  "instructions": null,
  "max_output_tokens": null,
  "model": "gpt-4.1-2025-04-14",
  "output": [
    {
      "type": "function_call",
      "id": "fc_67ca09c6bedc8190a7abfec07b1a1332096610f474011cc0",
      "call_id": "call_unLAR8MvFNptuiZK6K6HCy5k",
      "name": "get_current_weather",
      "arguments": "{\"location\":\"Boston, MA\",\"unit\":\"celsius\"}",
      "status": "completed"
    }
  ],
  "parallel_tool_calls": true,
  "previous_response_id": null,
  "reasoning": {
    "effort": null,
    "summary": null
  },
  "store": true,
  "temperature": 1.0,
  "text": {
    "format": {
      "type": "text"
    }
  },
  "tool_choice": "auto",
  "tools": [
    {
      "type": "function",
      "description": "Get the current weather in a given location",
      "name": "get_current_weather",
      "parameters": {
        "type": "object",
        "properties": {
          "location": {
            "type": "string",
            "description": "The city and state, e.g. San Francisco, CA"
          },
          "unit": {
            "type": "string",
            "enum": [
              "celsius",
              "fahrenheit"
            ]
          }
        },
        "required": [
          "location",
          "unit"
        ]
      },
      "strict": true
    }
  ],
  "top_p": 1.0,
  "truncation": "disabled",
  "usage": {
    "input_tokens": 291,
    "output_tokens": 23,
    "output_tokens_details": {
      "reasoning_tokens": 0
    },
    "total_tokens": 314
  },
  "user": null,
  "metadata": {}
}"#;

        // Try to deserialize the JSON
        let result: Result<ResponseObject, _> = serde_json::from_str(json);

        match result {
            Ok(response) => {
                // If deserialization succeeds, verify key fields
                assert_eq!(response.id, "resp_67ca09c5efe0819096d0511c92b8c890096610f474011cc0");
                assert_eq!(response.object, "response");
                assert_eq!(response.created_at, 1741294021);
                assert_eq!(response.status, "completed");
                assert_eq!(response.model, "gpt-4.1-2025-04-14");
                assert_eq!(response.parallel_tool_calls, true);
                assert_eq!(response.temperature, 1.0);
                assert_eq!(response.top_p, 1.0);

                // Check usage
                assert_eq!(response.usage.input_tokens, 291);
                assert_eq!(response.usage.output_tokens, 23);
                assert_eq!(response.usage.total_tokens, 314);
                assert_eq!(response.usage.output_tokens_details.reasoning_tokens, 0);

                // Check output
                assert_eq!(response.output.len(), 1);
                if let OutputItem::FunctionToolCall { id, call_id, name, arguments, status, .. } = &response.output[0] {
                    assert_eq!(id, "fc_67ca09c6bedc8190a7abfec07b1a1332096610f474011cc0");
                    assert_eq!(call_id, "call_unLAR8MvFNptuiZK6K6HCy5k");
                    assert_eq!(name, "get_current_weather");
                    assert_eq!(arguments, "{\"location\":\"Boston, MA\",\"unit\":\"celsius\"}");
                    assert_eq!(status, "completed");
                } else {
                    panic!("Expected FunctionToolCall variant");
                }

                // Check tools
                assert!(response.tools.is_some());
                let tools = response.tools.as_ref().unwrap();
                assert_eq!(tools.len(), 1);
                assert_eq!(tools[0].name, "get_current_weather");
                assert_eq!(tools[0].description, "Get the current weather in a given location");
                assert_eq!(tools[0].strict, true);

                println!("✅ ResponseObject deserialization successful!");
            }
            Err(e) => {
                // If deserialization fails, print the error and identify missing fields
                println!("❌ ResponseObject deserialization failed: {}", e);
                println!("This indicates that some fields in the JSON are not present in the ResponseObject struct.");
                println!("Missing fields likely include: reasoning, store, text, truncation, user");

                // For now, we'll expect this to fail since the struct is missing some fields
                // In a real scenario, we'd need to add these fields to the struct
                panic!("Expected deserialization to succeed, but got error: {}", e);
            }
        }
    }
}
